```
Verziókezelés, verziókezelő rendszerek. Szoftvertesztelési alapfogalmak (tesztszintek, teszttípusok,
teszttervezési módszerek). Objektum orientált tervezési alapelvek (GoF, SOLID). Függőség-
befecskendezés. Architekturális minták (MVC). Tervezési minták. Szabad és nem szabad
szoftverek. Szoftverlicencek, szabad és nyílt forrású licencek fajtái
```


- swe: https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/

## verziókezelés
## verziókezelő rendszerek

## tesztelési alapfogalmak
tesztszintek
teszttípusok

OOP tervezési alapelvek

ezek design patterns-ek:
	design pattern: középszintű minták, amelyek egy kisebb léptékű architekturális minta, cask egy alrendszer felépítését határozhatja meg, nem egy teljes szoftverrendszer felépítését
## GOF (gang of four)
forrás: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.

GOF alapelvek céljuk szerint:
- létrehozási minta
- szerkezeti minta
- viselkedési minta

(eredetileg 23 mintát ír le a GOF könyv)

példák:
### singleton

-> interfészre programmozunk ne implementációra
-> részesítsük előnyben az objektum összetételt az öröklődéssel szemben ????

## SOLID
forrás Robert C Martin (Uncle Bob)
- Single Responsibility Principle -> egyszeres felelősség elv
egy osztálynak csak egy oka legyen a változásra ????

- Open / Closed Principle -> nyitva zárt elv
szoftver entitások (pl osztályok) legyenek **nyitottak a kibővítésre**, de **zártak a módosításra** ???
-> modul viselkedése kiterjeszthető, modul viselkedésének kiterjeszése nem eredményezi az eredeti osztály / modul eredeti forrás- vagy bináriskódjának változását

- Liskov's Substitution Principle -> liskov-féle helyettesítése elv
forrás: Barbara Liskov
-> Ha egy S típus egy másik T típusoknak az altípusa, akkor a programban úgy helyettesíthetjük a T típusú osztályokat az S típusú osztályokkal, hogy az nem változtatja meg a program működését

- Interfaces Segregation Principle -> interfész szétválasztás elv
Az osztályokat nem szabad arra kényszeríteni, hogy olyan metódusoktól függjenek, amelyeket nem használnak

vastag interfész: "an interface with more methods and friends than that would be logically necessary"
ez az elv a vastag interfészeket -> ???. ....

interfész szennyezés: szükségtelen metódusok

- Dependency Inversion Principle -> Függőség megfordítás elv
magas szintű modulok ne függjenek alacsony szintű moduloktól -> mindkettő absztrakciótól függjeneke ?????

 (hollywood elv: ne hívj majd mi hívunk)

## DI: dependency injection
forrás: Martin Fowler

célja: achievintg loosely coupled software
egy objektumra olyan szolgáltatásként tekintünk, amelyet kliensként használunk => kliens-szolgáltató viszony osztályok között (ez tranzitiv? ?????...)

részek:
- depedency: kliens által igényelt szolgáltatás, amely a feladatának ellátásához szükséges
- dependant: a kliens objektum, amelynek szüksége van egy függőségre
- object graph: függő objektumok + függőségeik összessége
- injection: kliens függőségeinek megadása

(IOC (inversion of control) minta alkalmazásának speciális esete)

(DI/IOC Container): DI funkcionalitást nyújtó programkönyvtár

DI fajtái:
- konstruktor
- setter
- interface-el
- field (?)

DI előnyei:
- karbantarthatóság
- tesztelhetőség
- kiterjeszhetőség

## architectural patterns
-> szoftverrendszerek alapvető szerkezeti felépítésére adnak sémákat
	alrendszerek + ezek felelősségi körei + irányelvek alrendszerek között
PL: mikrokernel, MVC

## MVC:
(model - view - controller)
környezet: ember-gép felülettel rendelkező interaktív alkalmazások
probléma: legyen a felhasználói felület könnyedén változtatható
megoldás: az interaktív alkalmazásokat 3 részre osztjuk:
	model: adatok + funkcionalitások becsomagolása
	view (nézet): információkat jeleníti meg a felhasználói felületen
	controller (vezérlő): fogadja a bemenetet -> majd azt tovább adja a model vagy a view felé

![[Pasted image 20250216131720.png]]



PATTERNS:
minta: olyan problémát ír le, ami újra és újra felbukkan a környezetünkben, s aztán leírja hozzá a megoldás magját, oly módon, hogy a megoldás milliószor felhasználható legyen, anélkül, hogy valaha is kétszer ugyanúgy csinálnánk
minden minta 3 részből áll: környezet + probléma + a megoldás a problémára

patternek fajtái:
- architectural patterns, architectural styles (ezek nem ugyanazok)
- design patterns
- programming idioms / implementatin patterns
- test patterns
- UI patterns
- antipatterns



Szabad és nem szabad szoftverek.
Szoftverlicencek, szabad és nyílt forrású licencek fajtái
```
Verziókezelés, verziókezelő rendszerek. Szoftvertesztelési alapfogalmak (tesztszintek, teszttípusok, teszttervezési módszerek). Objektum orientált tervezési alapelvek (GoF, SOLID). Függőség-befecskendezés. Architekturális minták (MVC). Tervezési minták. Szabad és nem szabad szoftverek. Szoftverlicencek, szabad és nyílt forrású licencek fajtái
```

archived: https://arato.inf.unideb.hu/jeszenszky.peter/swe/archive/2024/
- swe: https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/
## Verziókezelés
A verziókövetés olyan eljárások összessége, amelyek lehetővé teszik egy adathalmaz változatainak (verzióinak) együttes kezelését. Szoftverek esetében a szoftver életciklusa során a forráskódban végzett módosítások tárolása, menedzselésére.

Haszna: a forráskód iterációkon megy keresztül, historikus adat nélkül nagy gond lehet olyan problémák megoldása, amely korábbi verzióra váltást igényelnek. Egy szoftveren többen is dolgoznak párhuzamosan: látni kell, hogy ki, mikor, mit fejlesztett. Menedzselni kell a merge-eket. Menedzsment számára rengeteg infót ad a fejlesztés menetéről.
## Verziókezelő rendszerek

A verziókezelés rendszerek lehetővé teszik, hogy:
- A verziókövetés alá helyezett minden állomány, minden korábbi változatát vissza lehet keresni.
- Egy állomány tetszőleges két változata közötti eltéréseket meg tudja jeleníteni
- Ha ketten egyszerre módosítjuk ugyanazt az állományt, akkor lehetőség szerint mindkettőjük módosításai megfelelően rögzítésre kerüljenek. Amennyiben a két módosítás ütközne egymással, a későbbi módosítást végző személy értesüljön a konfliktusról és dönteni tudjon arról, hogy milyen tartalom kerüljön be végül az állományba ==> Git használatakor a MERGE CONFLICT-EK MEGOLDÁSA ()
- Elágazásokat (git: branch - ágak) hozhatunk létre. Tegyük fel, hogy az alap szoftverünkből készítünk egy ingyenes és egy tulajdonosi verziót is, akkor ezeket külön ágra (branch) helyezhetjük. A későbbiekben ezeket külön-külön fejleszthetjük.

Verziókezelő rendszerek például:
- Git
- Subversion

A következőek nem verziókezelő rendszerek, hanem Git szolgáltatók.
- Github
- Gitlab

## Szoftvertesztelési alapfogalmak

https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/testing_hu.pdf

Mi a tesztelés?
->A szoftvertesztelés egy megoldás a szoftver minőségének megállapításához és a szoftver működés közbeni meghibásodási
kockázatának csökkentésére.
![[Pasted image 20250528173806.png]]

A szoftvertesztelés korlátai:
	- A tesztelés csökkenti a szoftverben fennmaradó felfedezetlen hibák valószínűségét, de a tesztelés még akkor sem a helyesség bizonyítéke, ha egyetlen hiba sem kerül megtalálásra.
	- Dijkstra: "A tesztelés csak hibák jelenlétét tudja mutatni, a hiányukat nem"

A szoftvertesztelés egy tágabb folyamat, a szoftver verifikáció és validáció (V & V) része:
- Verifikáció (verification): annak ellenőrzése, hogy a szoftver megfelel-e a vele szemben támasztott (funkcionális és nem funkcionális) követelményeknek
	- Vagyis: A terméket JÓL építjük-e?
- Validáció (validation): annak az ellenőrzése, hogy a szoftver megfelel-e az ügyfél elvárásainak
	- Vagyis: A JÓ terméket építjük?

megj:
Hibák típusai:
- Tévedés / Error: Rossz eredményt adó emberi tevékenység
- HIba / Bug: Munkatermékben jelenlévő tökéletlenség vagy hiányosság ??
- Meghibásodás / Failure: Esemény, melynél komponens vagy rendszer nem ér el egy megkövetelt funkciót a megszabott határok között

A tesztelés 7 alapelve:
![[Pasted image 20250603102218.png]]

Teszteset: Tesztfeltétel alapján meghatározott előfeltételek, bemenetek, tevékenységek, elvárt eredmények és utófeltételek halmaza
- tesztfeltétel: egy komponens vagy rendszer tesztelhető vonása, amelyet a tesztelés alapjál választunk
- magasszintű teszteset: teszteset, amely absztrakt előfeltételekkel, bemeneti adatokkal, elvárt eredményekkel, utófeltételekkel és (adott esetben) lépésekkel rendelkezik.
- alacsonyszintű teszteset: Teszteset, amely KONKRÉT -||-

Tesztadat: A tesztvégrehajtásakor szükséges adatok.
->A tesztadatok, a magasszintű teszteseteket, alacsonyszintű tesztesetekké alakítjákat, vagyis
TODO kibővíteni ?

Tesztfolyamat: a szoftverfejlesztés számos különböző tevékenységet magában foglaló folymaat, nincs univerzális tesztfolyamat, csak jól bevett tesztelési tevékenységek

Tesztfolyamat lépései:
![[Pasted image 20250603104720.png]]

Szoftvertesztelési folyamat modellje:
![[Pasted image 20250603104950.png]]
- A tesztadatok néha automatikusan generálhatóak
- A teszteseteket NEM lehet automatikusan generálni. A várt teszteredmények meghatározása olyan emberek bevonásával szükséges, hogy történjen, akik értik a rendszer elvárt viselkedését
- A tesztvégrehajtás is automatizálható => teszteredmények automatikusan összehasonlíthatóak a várt eredményekkel (ehhez nem kell ember aki az anomáliakat keresi a tesztfutásakor)

Fejlesztői tesztelés: a rendszert a fejlesztők is tesztelk fejlesztés közben (egységteszt, integrációs tesztelés), független teszelők is dolgozhatnak a teszelésen
Felhasználói tesztelés: a felhasználók vagy potencionális felhasználók a sajátkörnyezetükben tesztelhetik a rendszert (például elfogadási teszt)

### Tesztszintek: a tesztelés különböző szinten végezhető a szoftverfejlesztési folyamatban
- 1, EGYSÉGTESZT (unit test, másnéven komponens tesztelés):
	- A függetlenül tesztelhető komponensekre összepontosít
	- egységtesztelést általában az a fejlesztő végzi aki a kódot írja
	- lehetséges, hogy komponens tesztek megírása megelőzi az alkalmazáskód megírását pl TDD (test driven development, tesztvezérelt fejlesztés)
- 2, KOMPONENS INTEGRÁCIÓS TESZTELÉS (component integration testing):
	- Az integrált komponens kommunikációjára és interfészjeire fokuszál (általában a fejlesztők végzik)
	- egységtesztelés után végzik és általában automatizált (?)
	- fejlesztők felelőssége
	- magára a komponensek integrációjára összepontosít, és nem a komponensek egyéni működésére
- 3, Rendszertesztelés (system testing):
	- A rendszer egészének (funkcionális és nem funkcionális) viselkedésére összepontosít
	- jellemzően nem a fejlesztők végzik, hanem FÜGGETLEN TESZTELŐK, a specifikációkra támaszkodva
- 4, RENDSZERINTEGRÁCIÓS TESZTELÉS (system integration testing):
	- rendszerek közötti kommunikációra és interfészekre összepontosít
	- A rendszer integrációs tesztelés általában tesztelők felelőssége
- 5, ELFOGADÁSI TESZTELÉS (acceptance test): 
	- annak meghatározására összpontosít, hogy a rendszer kész-e a telepítésre és ügyfél és végfelhasználók általi használatra
	- alfa tesztelés: felhasználók kis kiválasztott csoportjának adjak oda az elkészült terméket tesztelésre (vagyis kipróbálásra)
	    - fejlesztő szervezet helyén
	- béta tesztelés: felhasználók egy nagyobb halmazának adják oda a terméket tesztelésre, ez a felhasználói csoport REPREZENTATÍV
	    - felhasználók helyén
	    - marketing egy formája
	    - főleg akkor jó, ha több környezetben is működnie kell az alkalmazásak

### Teszttípusok: tesztelés átfogó célja szerint. ezek bármelyike alkalmazható bármelyik tesztszintre
- funkcionális: annak tesztelése amit a rendszer csinál, funkciók tesztelése -> minden teszt szinten ajánlott végezni
- nem funkcionális: annak tesztelése, hogy a rendszer milyen jól működik
	  - pl használhatóság, teljesítmény vagy biztonság, stressz
- fekete dobozos
	- a rendszer belső működését nem ismerjük a tesztelés során
	- célja: rendszer működésének összevetése a specifikációval
- fehér dobozos:
	  - a rendszer belső felépítésén alapuló tesztelés
- változtatással kapcsolatos tesztelés: -> szükséges minden tesztelési szinten
	- megerősítéses tesztelés: a javított hiba megjavult-e
	- regressziós tesztelés: a kódbázisban elvégzett módosítás nem rontottak-e el valamit az eddig jól működő részeiben a rendszernek

### TESZTTERVEZÉSI MÓDSZEREK
• Tesztelő tapasztalata
• Specifikáció alapú
• Struktúra alapú (ismerjük a program felépítését)
• Hiba alapú (hibasejtés)
• Valószínűség (determinisztikus módon is lehet)

### Objektum orientált tervezési alapelvek

DRY (Don't Repeat Yourself)
KISS (Keep it simple studid)
YAGNI (You aren't going to need it)
## GoF (gang of four)
A GoF tervezési mintákat (design pattern-eket határzoknak meg)
Ezen tervezéis minták a következő könyvben lett meghatározva a 4 szerző által: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.
##### 1. Interfészre programozzunk, ne implementációra!

##### 2. Részesítsük előnyben az objektum-összetételt az öröklődéssel szemben!

GoF alapelvek céljuk szerint:
- létrehozási minta
- struktúrális/szerkezeti minta
- viselkedési minta

(eredetileg 23 mintát ír le a GOF könyv)

## SOLID
forrás Robert C Martin (Uncle Bob)
- **S**ingle Responsibility Principle -> egyszeres felelősség elv
  egy osztálynak csak egy oka legyen a változásra ????
- **O**pen / Closed Principle -> nyitva zárt elv
  szoftver entitások (pl osztályok) legyenek **nyitottak a kibővítésre**, de **zártak a módosításra**
  -> modul viselkedése kiterjeszthető, modul viselkedésének kiterjeszése nem eredményezi az seredeti osztály / modul eredeti forrás- vagy bináriskódjának változását
- Liskov's Substitution Principle -> liskov-féle helyettesítése elv
  forrás: Barbara Liskov
  -> Ha egy S típus egy másik T típusoknak az altípusa, akkor a programban úgy helyettesíthetjük a T típusú osztályokat az S típusú osztályokkal, hogy az nem változtatja meg a program működését
- Interfaces Segregation Principle -> interfész szétválasztás elv
  Az osztályokat nem szabad arra kényszeríteni, hogy olyan metódusoktól függjenek, amelyeket nem használnak
vastag interfész: "an interface with more methods and friends than that would be logically necessary"
ez az elv a vastag interfészeket -> ???. ....
interfész szennyezés: szükségtelen metódusok

- Dependency Inversion Principle -> Függőség megfordítás elv
  magas szintű modulok ne függjenek alacsony szintű moduloktól -> mindkettő absztrakciótól függjenek ?????

(hollywood elv: ne hívj majd mi hívunk)

## Függőség-befecskendezés
forrás: Martin Fowler

Az IoC (Inversion of Control) minta alkalmazása.
célja: achieving loosely coupled software
egy objektumra olyan szolgáltatásként tekintünk, amelyet kliensként használunk => kliens-szolgáltató viszony osztályok között (ez tranzitiv? ?????...)

részek:
- depedency: kliens által igényelt szolgáltatás, amely a feladatának ellátásához szükséges
- dependant: a kliens objektum, amelynek szüksége van egy függőségre
- object graph: függő objektumok + függőségeik összessége
- injection: kliens függőségeinek megadása

(DI/IOC Container): DI funkcionalitást nyújtó programkönyvtár

DI fajtái: setter, field, konstruktor

DI előnyei:
- karbantarthatóság
- tesztelhetőség
- kiterjeszhetőség

## Architekturális minták
-> szoftverrendszerek alapvető szerkezeti felépítésére adnak sémákat
alrendszerek + ezek felelősségi körei + irányelvek alrendszerek között
PL: mikrokernel, MVC

## MVC:
(model - view - controller)
környezet: ember-gép felülettel rendelkező interaktív alkalmazások
probléma: legyen a felhasználói felület könnyedén változtatható
megoldás: az interaktív alkalmazásokat 3 részre osztjuk:
model: adatok + funkcionalitások becsomagolása
view (nézet): információkat jeleníti meg a felhasználói felületen
controller (vezérlő): fogadja a bemenetet -> majd azt tovább adja a model vagy a view felé

![[Pasted image 20250216131720.png]]

### Tervezési minták
Angolul: design patternek.
-> középszintű minták, amelyek egy kisebb léptékű minta, csak egy alrendszer felépítését határozhatja meg, nem egy teljes szoftverrendszer felépítését

Minta: olyan problémát ír le, ami újra és újra felbukkan a környezetünkben, s aztán leírja hozzá a megoldás magját, oly módon, hogy a megoldás milliószor felhasználható legyen, anélkül, hogy valaha is kétszer ugyanúgy csinálnánk
minden minta 3 részből áll: környezet + probléma + a megoldás a problémára

TODO delete this BS
(minták fajtái:
- architectural patterns, architectural styles (ezek nem ugyanazok)
- design patterns
- programming idioms / implementatin patterns
- test patterns
- UI patterns
- antipatterns)

### Szabad szoftverek
Általános módon:
- tetszőleges célra használható
- működése szabadon tanulmányozható
- másolatait szabadon lehet terjeszteni
- szabadon módosítható

-> Nyílt forráskódú szoftverek (szabad szoftver és szabad szoft. inkább motivációbei különsége van mint gyakorlatbeli)

-> eltérő megközelítés a szabad szoftverre: Open source (nyílt forráskódú)
https://opensource.org/osd

alternatív elnevezés: FOSS: Free and Open Source software

### Nem szabad szoftverek.
A használat és terjesztés tilos, korlátozott vagy engedélyhez kötött
másnéven: zárt forrású kód (closed source), tulajdonosi szoftver (proprietery)

-> privát szoftver: egy adott cég vagy személyes kérésére készült egyéni szoftver -> a cég vagy egyén magának megtartja és nem teszi nyilvánossa


https://hu.wikipedia.org/wiki/Szabad_szoftver
http://sugo.ubuntu.hu/10.10/html/add-applications/hu/restricted-software.html

### Szoftverlicencek
-> szoftverek használatának és terjesztésének módját szabályozó jogi eszköz

### Szabad és nyílt forrású licencek fajtái
#### szabad:
->non-copyleft: **megengedő (permissive)**: minimális mértékben korlátoznak
		-> Pl Apache License 2.0, BSD licensek, MIT License
-> copyleft: "elidegenídhetetlen köztulajdon"
	Alkotás módosításait is ugyanolyan licensz alatt kell terjeszteni mint az eredetit
	pl: Emacs General Public License, GNU GPL 
#### nem szabad:
-> kereskedelmi szoftver
-> free ware: szabadon terjeszhetőek, de nem módosítható (forráskód sem elérhető)
-> shareware: szabadon terjeszthető, de használata feltételek mellett leheteséges, amelyek bevételt generálnak a szerzőnek

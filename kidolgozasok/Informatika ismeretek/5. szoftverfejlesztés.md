```
Verziókezelés, verziókezelő rendszerek. Szoftvertesztelési alapfogalmak (tesztszintek, teszttípusok, teszttervezési módszerek). Objektum orientált tervezési alapelvek (GoF, SOLID). Függőség-befecskendezés. Architekturális minták (MVC). Tervezési minták. Szabad és nem szabad szoftverek. Szoftverlicencek, szabad és nyílt forrású licencek fajtái
```

archived: https://arato.inf.unideb.hu/jeszenszky.peter/swe/archive/2024/
- swe: https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/
## Verziókezelés
A verziókövetés olyan eljárások összessége, amelyek lehetővé teszik egy adathalmaz változatainak (verzióinak) együttes kezelését. Szoftverek esetében a szoftver életciklusa során a forráskódban végzett módosítások tárolása, menedzselésére.

Haszna: a forráskód iterációkon megy keresztül, historikus adat nélkül nagy gond lehet olyan problémák megoldása, amely korábbi verzióra váltást igényelnek. Egy szoftveren többen is dolgoznak párhuzamosan: látni kell, hogy ki, mikor, mit fejlesztett. Menedzselni kell a merge-eket. Menedzsment számára rengeteg infót ad a fejlesztés menetéről.
## Verziókezelő rendszerek

A verziókezelés rendszerek lehetővé teszik, hogy:
- A verziókövetés alá helyezett minden állomány, minden korábbi változatát vissza lehet keresni.
- Egy állomány tetszőleges két változata közötti eltéréseket meg tudja jeleníteni
- Ha ketten egyszerre módosítjuk ugyanazt az állományt, akkor lehetőség szerint mindkettőjük módosításai megfelelően rögzítésre kerüljenek. Amennyiben a két módosítás ütközne egymással, a későbbi módosítást végző személy értesüljön a konfliktusról és dönteni tudjon arról, hogy milyen tartalom kerüljön be végül az állományba ==> Git használatakor a MERGE CONFLICT-EK MEGOLDÁSA ()
- Elágazásokat (git: branch - ágak) hozhatunk létre. Tegyük fel, hogy az alap szoftverünkből készítünk egy ingyenes és egy tulajdonosi verziót is, akkor ezeket külön ágra (branch) helyezhetjük. A későbbiekben ezeket külön-külön fejleszthetjük.

Verziókezelő rendszerek például:
- Git
- Subversion

A következőek nem verziókezelő rendszerek, hanem Git szolgáltatók.
- Github
- Gitlab

## Szoftvertesztelési alapfogalmak

https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/testing_hu.pdf

Mi a tesztelés?
->A szoftvertesztelés egy megoldás a szoftver minőségének megállapításához és a szoftver működés közbeni meghibásodási
kockázatának csökkentésére.
![[Pasted image 20250528173806.png]]

A szoftvertesztelés korlátai:
	- A tesztelés csökkenti a szoftverben fennmaradó felfedezetlen hibák valószínűségét, de a tesztelés még akkor sem a helyesség bizonyítéke, ha egyetlen hiba sem kerül megtalálásra.
	- Dijkstra: "A tesztelés csak hibák jelenlétét tudja mutatni, a hiányukat nem"

A szoftvertesztelés egy tágabb folyamat, a szoftver verifikáció és validáció (V & V) része:
- Verifikáció (verification): annak ellenőrzése, hogy a szoftver megfelel-e a vele szemben támasztott (funkcionális és nem funkcionális) követelményeknek
	- Vagyis: A terméket JÓL építjük-e?
- Validáció (validation): annak az ellenőrzése, hogy a szoftver megfelel-e az ügyfél elvárásainak
	- Vagyis: A JÓ terméket építjük?

megj:
Hibák típusai:
- Tévedés / Error: Rossz eredményt adó emberi tevékenység
- HIba / Bug: Munkatermékben jelenlévő tökéletlenség vagy hiányosság ??
- Meghibásodás / Failure: Esemény, melynél komponens vagy rendszer nem ér el egy megkövetelt funkciót a megszabott határok között

A tesztelés 7 alapelve:
![[Pasted image 20250603102218.png]]

Teszteset: Tesztfeltétel alapján meghatározott előfeltételek, bemenetek, tevékenységek, elvárt eredmények és utófeltételek halmaza
- tesztfeltétel: egy komponens vagy rendszer tesztelhető vonása, amelyet a tesztelés alapjál választunk
- magasszintű teszteset: teszteset, amely absztrakt előfeltételekkel, bemeneti adatokkal, elvárt eredményekkel, utófeltételekkel és (adott esetben) lépésekkel rendelkezik.
- alacsonyszintű teszteset: Teszteset, amely KONKRÉT -||-

Tesztadat: A tesztvégrehajtásakor szükséges adatok.
->A tesztadatok, a magasszintű teszteseteket, alacsonyszintű tesztesetekké alakítjákat, vagyis
TODO kibővíteni ?

Tesztfolyamat: a szoftverfejlesztés számos különböző tevékenységet magában foglaló folymaat, nincs univerzális tesztfolyamat, csak jól bevett tesztelési tevékenységek

Tesztfolyamat lépései:
![[Pasted image 20250603104720.png]]

Szoftvertesztelési folyamat modellje:
![[Pasted image 20250603104950.png]]
- A tesztadatok néha automatikusan generálhatóak
- A teszteseteket NEM lehet automatikusan generálni. A várt teszteredmények meghatározása olyan emberek bevonásával szükséges, hogy történjen, akik értik a rendszer elvárt viselkedését
- A tesztvégrehajtás is automatizálható => teszteredmények automatikusan összehasonlíthatóak a várt eredményekkel (ehhez nem kell ember aki az anomáliakat keresi a tesztfutásakor)

Fejlesztői tesztelés: a rendszert a fejlesztők is tesztelk fejlesztés közben (egységteszt, integrációs tesztelés), független teszelők is dolgozhatnak a teszelésen
Felhasználói tesztelés: a felhasználók vagy potencionális felhasználók a sajátkörnyezetükben tesztelhetik a rendszert (például elfogadási teszt)

### Tesztszintek: a tesztelés különböző szinten végezhető a szoftverfejlesztési folyamatban
- 1, EGYSÉGTESZT (unit test, másnéven komponens tesztelés):
	- A függetlenül tesztelhető komponensekre összepontosít
	- egységtesztelést általában az a fejlesztő végzi aki a kódot írja
	- lehetséges, hogy komponens tesztek megírása megelőzi az alkalmazáskód megírását pl TDD (test driven development, tesztvezérelt fejlesztés)
- 2, KOMPONENS INTEGRÁCIÓS TESZTELÉS (component integration testing):
	- Az integrált komponens kommunikációjára és interfészjeire fokuszál (általában a fejlesztők végzik)
	- egységtesztelés után végzik és általában automatizált (?)
	- fejlesztők felelőssége
	- magára a komponensek integrációjára összepontosít, és nem a komponensek egyéni működésére
- 3, Rendszertesztelés (system testing):
	- A rendszer egészének (funkcionális és nem funkcionális) viselkedésére összepontosít
	- jellemzően nem a fejlesztők végzik, hanem FÜGGETLEN TESZTELŐK, a specifikációkra támaszkodva
- 4, RENDSZERINTEGRÁCIÓS TESZTELÉS (system integration testing):
	- rendszerek közötti kommunikációra és interfészekre összepontosít
	- A rendszer integrációs tesztelés általában tesztelők felelőssége
- 5, ELFOGADÁSI TESZTELÉS (acceptance test): 
	- annak meghatározására összpontosít, hogy a rendszer kész-e a telepítésre és ügyfél és végfelhasználók általi használatra
	- alfa tesztelés: felhasználók kis kiválasztott csoportjának adjak oda az elkészült terméket tesztelésre (vagyis kipróbálásra)
	    - fejlesztő szervezet helyén
	- béta tesztelés: felhasználók egy nagyobb halmazának adják oda a terméket tesztelésre, ez a felhasználói csoport REPREZENTATÍV
	    - felhasználók helyén
	    - marketing egy formája
	    - főleg akkor jó, ha több környezetben is működnie kell az alkalmazásak

### Teszttípusok: A tesztelés átfogó célját határozzák meg. A teszttípusok bármelyike alkalmazható bármelyik tesztelési szinten
- 1, FUNKCIONÁLIS:
	- annak tesztelése amit a rendszer csinál, funkciók tesztelése -> minden teszt szinten ajánlott végezni
	- más szóval annak tesztelése amit a rendszer csinál
- 2, NEM FUNKCIONÁLIS:
	- annak tesztelése, hogy a rendszer MILYEN JÓL működik
	- például: használhatóság, teljesítmény vagy biztonság
- 3, FEKETE DOBOZOS:
	- a rendszer belső működését nem ismerjük a tesztelés során
	- célja: rendszer működésének összevetése a specifikációval
- 4, FEHÉR DOBOZOS:
	  - a rendszer belső felépítésén alapuló tesztelés
	  - a tesztelők ismerik a rendszer belső felépítését
- 5, VÁLTOZTATÁSSAL KAPCSOLATOS tesztelés: teszteket kell végezni, amikor módosítások történnek egy rendszerben, például egy hiba kijavítása, új funkcionalitás hozzáadása vagy régi funkcionálitás kibővítése/módosítása
	- MEGERŐSÍTÉSES: a javított hiba megjavult-e
	- REGRESSZIÓS tesztelés: a kódbázisban elvégzett módosítás nem rontottak-e el valamit az eddig jól működő részeiben a rendszernek

### Teszttervezési módszerek
• Tesztelő tapasztalata
• Specifikáció alapú
• Struktúra alapú (ismerjük a program felépítését, van részletes tervünk ezen a ponton?)
• Hiba alapú (hibasejtés)
• Valószínűség (determinisztikus módon is lehet)

### Objektum orientált tervezési alapelvek

DRY: "Don't Repeat Yourself"
- kerüljük az információ ismétlést (azonos forráskódrész, amely többször jelenik meg a forráskódban) ?,? pontosítani

KISS: "Keep it simple stupid"
- Legyenek a dolgok minél egyszerűbbek

YAGNI: "You aren't going to need it"
- Mindig akkor implementáljunk valamit amikor ténylegesen szükségünk van rá (és nem hamarabb, mivel lehet hogy soha se lesz valamire szükséges)

Demeter törvénye: "Don't talk to strangers"
- ??

Csatoltság (coupling):
- szoftver modulok egymástól való függőségüknek a mértéke
- lehet szoros (close coupling) vagy laza (loose coupling)
- mindig a LAZA csatoltságra (loose coupling) törekszünk -> ez lehetővé teszi a nyitva zárt elvet -> lehetőség van kiterjeszthetőségre

## GoF (gang of four)
A GangOfFour objektum orientált tervezési mintákat (design pattern-eket határoznak meg)
Ezen tervezéis minták a következő könyvben lett meghatározva a 4 szerző által: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.
##### 1. Interfészre programozzunk, ne implementációra!

##### 2. Részesítsük előnyben az objektum-összetételt az öröklődéssel szemben!

GoF alapelvek céljuk szerint:
- létrehozási minta
- struktúrális/szerkezeti minta
- viselkedési minta

(eredetileg 23 mintát ír le a GOF könyv)

## SOLID
forrás Robert C Martin (Uncle Bob)
- **S**ingle Responsibility Principle -> egyszeres felelősség elv
	-  minden osztálynak egy felelőssége legyen, azaz egy oka a változásra
	- ha egynél több felelősség, akkor szorosan csatolttá válik
	- egy osztály csak egy szereplőnek legyen alá rendelve
- **O**pen / Closed Principle -> Nyitva zárt elv
	 - szoftver entitások (pl osztályok) legyenek **nyitottak a kibővítésre**, de **zártak a módosításra**
		  -> nyitott a bővítésre: modul viselkedése kiterjeszthető
		 - -> zárt a módosításra: modul viselkedésének kiterjesztése nem jelenti a modul forráskódjának változását
- **L**iskov's Substitution Principle -> Liskov-féle helyettesítése elv (forrás: Barbara Liskov)
	- Ha egy S típus egy másik T típusoknak az altípusa, akkor a programban úgy helyettesíthetjük a T típusú osztályokat az S típusú osztályokkal, hogy az nem változtatja meg a program működését
	- magyarul: egy altípusbeli osztályt behelyettesítve egy szülőtípusú osztály helyére nem állhat meg a program működése
- Interfaces Segregation Principle -> interfész szétválasztási elv:
	- Az osztályokat nem szabad arra kényszeríteni, hogy olyan metódusoktól függjenek, amelyeket nem használnak
	- Az ISP ezzel foglalkozik: Vastag interfész: egy olyan interfész, amely túl sok tagfügvénnyel rendelkezik
	- ISP célja, hogy csináljunk koherens interface-eket
	- kereljük el: Interfész szennyezés: interface-ek telepakolása szükségtelen metódusok
- **D**ependency Inversion Principle -> Függőség megfordítás elv
	- Magas szintű modulok ne függjenek alacsony szintű moduloktól -> mindkettő absztrakciótól függjön
		- magasszintű modulok tartalmazzák az alkalmazás üzleti logikáját
		- a cél, hogy az alkalmazás na konkrét osztályoktól függjön, hanem interface-ektől és absztrakt osztályoktól

(hollywood elv: ne hívj majd mi hívunk)
## Függőség-befecskendezés
forrás: Martin Fowler

Az IoC (Inversion of Control) minta alkalmazása.
Célja: lazán csatolt kód elérése -> a lazán csatolt kód kiterjeszhetőséget és karbantarthatóságot fog eredményezni

Egy objektumra szolgáltatásként tekintünk, amelyet kliensként használunk => kliens-szolgáltató viszony osztályok között

A függőség befecskendezésben részt vevő tagok:
- függőség (dependency): kliens által igényelt szolgáltatás, amely a kliens feladatának ellátásához szükséges
- függő (dependant): a kliens objektum, amelynek szüksége van egy függőségre
- objektum gráf (object graph): függő objektumok + függőségeik összessége
- befecskendezés (injection): egy kliens függőségeinek megadása

DI/IOC Container: DI funkcionalitást nyújtó programkönyvtár

Depdency injection típusai:
- setter
- field (mező)
- konstruktor

DI előnyei:
- karbantarthatóság
- tesztelhetőség
- kiterjeszhetőség

## Architekturális minták
A szoftverrendszerek alapvető szerkezetét leíró sémák.
Előre definiált alrendszerek + alrendszerek felelősségi körei + irányelvek alrendszerek között

Példák architekturális mintákra: mikrokernel, MVC, microservice (mikroszolgáltatások)

## MVC:
Model - View - Controller

Az MVC egy architekturális minta.

KÖRNYEZET: ember-gép felülettel rendelkező interaktív alkalmazások.

PROBLÉMA: legyen a felhasználói felület könnyedén változtatható, mivel a felhasználói felület változtatására gyakran van igény.

MEGOLDÁS: Az interaktív alkalmazásokat 3 részre osztjuk:
- MODEL: adatok + funkcionalitások becsomagolása -> ÜZLETI LOGIKA
- VIEW (nézet): információkat jeleníti meg a felhasználói felületen
- CONTOLLER (vezérlő): fogadja a bemenetet -> majd azt tovább adja a model vagy a view felé

![[Pasted image 20250216131720.png]]

### Tervezési minták
(angolul: design pattern-ek)

Középszintű minták, amelyek kisebb léptékű minták, csak egy alrendszer felépítését határozzák meg, nem egy teljes szoftverrendszer felépítését.

Minta: olyan problémát ír le, ami újra és újra felbukkan a környezetünkben, s aztán leírja hozzá a megoldás magját, oly módon, hogy a megoldás milliószor felhasználható legyen, anélkül, hogy valaha is kétszer ugyanúgy csinálnánk
minden minta 3 részből áll: környezet + probléma + a megoldás a problémára

### Szabad szoftverek
A szabadság a következőket jelenti:
- 1, A szoftver tetszőleges célra szabadon használható
- 2, A szoftver működése szabadon tanulmányozható
- 3, A szoftver másolatait szabadon lehet terjeszteni
- 4, A szoftver szabadon módosítható

-> Nyílt forráskódú szoftverek (szabad szoftver és szabad szoft. inkább motivációbeli különsége van mint gyakorlatbeli)

-> eltérő megközelítés a szabad szoftverre: Open source (nyílt forráskódú)
https://opensource.org/osd

alternatív elnevezés: FOSS: Free and Open Source software

### Nem szabad szoftverek.
A használat, terjesztés és módosítás tilos, korlátozott vagy engedélyhez kötött.
másnéven: zárt forrású kód (closed source), tulajdonosi szoftver (proprietery)

-> privát szoftver: egy adott cég vagy személyes kérésére készült egyéni szoftver -> a cég vagy egyén magának megtartja és nem teszi nyilvánossa


https://hu.wikipedia.org/wiki/Szabad_szoftver
http://sugo.ubuntu.hu/10.10/html/add-applications/hu/restricted-software.html

### Szoftverlicencek
-> szoftverek használatának és terjesztésének módját szabályozó jogi eszköz
Amennyiben nem szabad szoftverről van szó akkor végfelhasználói licencszerződés kifejezést használjuk.

### Szabad és nyílt forrású licencek fajtái
#### Szabad licencek fajtái:
- **megengedő (permissive)** (non-copyleft): minimális mértékben korlátoznak
	- Pl Apache License 2.0, MIT License, BSD licensek
	- ezen szoftvereket felhasználhatjuk nem szabad szoftverek elkészítéséhez ?
- Copyleft: a copy left licencek használata "elidegenídhetetlen köztulajdon"-t hoznak létre
	- Alkotás módosításait is ugyanolyan licensz alatt kell terjeszteni mint az eredetit
	- pl: Emacs General Public License, GNU GPL
	- minden olyan szoftver, amelyet copy left licenccel rendelkező szoftverek felhasználásával (mármint forráskód) készítettünk el, azokat is ugyanazon licenc alá kell helyezni.



megj:
#### Nem szabad licencek:
-> kereskedelmi szoftver
-> free ware: szabadon terjeszhetőek, de nem módosítható (forráskód sem elérhető)
-> shareware: szabadon terjeszthető, de használata feltételek mellett leheteséges, amelyek bevételt generálnak a szerzőnek

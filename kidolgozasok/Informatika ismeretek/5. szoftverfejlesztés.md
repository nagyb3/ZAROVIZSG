```
Verziókezelés, verziókezelő rendszerek. Szoftvertesztelési alapfogalmak (tesztszintek, teszttípusok, teszttervezési módszerek). Objektum orientált tervezési alapelvek (GoF, SOLID). Függőség-befecskendezés. Architekturális minták (MVC). Tervezési minták. Szabad és nem szabad szoftverek. Szoftverlicencek, szabad és nyílt forrású licencek fajtái
```

archived: https://arato.inf.unideb.hu/jeszenszky.peter/swe/archive/2024/

- swe: https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/

## Verziókezelés
Pro Git:
- Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later.
## verziókezelő rendszerek

## szoftvertesztelési alapfogalmak

https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/testing_hu.pdf

**Tesztszintek:** a tesztelés különböző szinten végezhető a szoftverfejlesztési folyamatban
- egység / komponens teszt (unit test): egy darab egyedülálló komponens tesztelése, általában a komponens implementációja során kerül a unit test is megírásra a fejlesztő által
  - jó egység teszt: FIRST:
    - Fast
    - Independent
    - Repeatable
    - Self-validating: logikai kimenet kell hogy legyen
    - Timely: -> jó időben kerüljenek megírásra == a teszteket a kód megírása előtt készítsük el
  - AAA minta: (also: GivenWhenThen)
    - Arrange -> tesztelt rendszert egy adott állapotba juttatja el
    - Act -> tesztelt rendszer adott funkcióját meghívja
    - Assert -> kimenetel ellenőrzése
- komponens integrációs tesztelés (component / unit integration testing): integrált komponen kommunikációjára és interfészjeire fokuszál (done by the dev)
- rendszertesztelés: nem a dev-ek végzik, hanem független tesztelők a specifikációk alapján
- rendszer integrációs tesztelés: több rendszer közötti kommunikációnak a tesztelése és azoknak az interfészei (tesztelők felelősége)
- elfogadási tesztelés (acceptance test): ügyfél vagy rendszerüzemeltetők felelősége, annak a tesztelése, hogy egy szoftver megfelelőe a végleges átadásra a megrendelők számára
  - alfa tesztelés: felhasználók kis kiválasztott csoportja
    - fejlesztő szervezet helyén
  - béta tesztelés: reprezentatív felhasználók nagyobb halmaza
    - felhasználók helyén
    - marketing egy formája
    - főleg akkor jó, ha több környezetben is működnie kell az alkalmazásak

**Teszttípusok:** tesztelés átfogó célja szerint. ezek bármelyike alkalmazható bármelyik tesztszintre

- funkcionális: annak tesztelése amit a rendszer csinál, funkciók tesztelése -> minden teszt szinten ajánlott végezni
- nem funkcionális: annak tesztelése, hogy a rendszer milyen jól működik
  - pl használhatóság, teljesítmény vagy biztonság
- fekete dobozos
  - a rendszer belső működését nem ismerjük a tesztelés során
  - célja: rendszer működésének összevetése a specifikációval
- fehér dobozos:
  - a rendszer belső felépítésén alapuló tesztelés
- változtatással kapcsolatos tesztelés: -> szükséges minden tesztelési szinten
  - megerősítéses tesztelés: a javított hiba megjavult-e
  - regressziós tesztelés: a kódbázisban elvégzett módosítás nem rontottak-e el valamit az eddig jól működő részeiben a rendszernek

### TESZTTERVEZÉSI MÓDSZEREK
?????
- mi a célja??
- milyen időnként futnak le a tesztek??

### Objektum orientált tervezési alapelvek

## GoF (gang of four)
forrás: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.

GOF alapelvek céljuk szerint:
- létrehozási minta
- szerkezeti minta
- viselkedési minta

(eredetileg 23 mintát ír le a GOF könyv)

## SOLID
forrás Robert C Martin (Uncle Bob)
- Single Responsibility Principle -> egyszeres felelősség elv
  egy osztálynak csak egy oka legyen a változásra ????

- Open / Closed Principle -> nyitva zárt elv
  szoftver entitások (pl osztályok) legyenek **nyitottak a kibővítésre**, de **zártak a módosításra** ???
  -> modul viselkedése kiterjeszthető, modul viselkedésének kiterjeszése nem eredményezi az eredeti osztály / modul eredeti forrás- vagy bináriskódjának változását

- Liskov's Substitution Principle -> liskov-féle helyettesítése elv
  forrás: Barbara Liskov
  -> Ha egy S típus egy másik T típusoknak az altípusa, akkor a programban úgy helyettesíthetjük a T típusú osztályokat az S típusú osztályokkal, hogy az nem változtatja meg a program működését

- Interfaces Segregation Principle -> interfész szétválasztás elv
  Az osztályokat nem szabad arra kényszeríteni, hogy olyan metódusoktól függjenek, amelyeket nem használnak

vastag interfész: "an interface with more methods and friends than that would be logically necessary"
ez az elv a vastag interfészeket -> ???. ....

interfész szennyezés: szükségtelen metódusok

- Dependency Inversion Principle -> Függőség megfordítás elv
  magas szintű modulok ne függjenek alacsony szintű moduloktól -> mindkettő absztrakciótól függjenek ?????

(hollywood elv: ne hívj majd mi hívunk)

## Függőség-befecskendezés

forrás: Martin Fowler

célja: achievintg loosely coupled software
egy objektumra olyan szolgáltatásként tekintünk, amelyet kliensként használunk => kliens-szolgáltató viszony osztályok között (ez tranzitiv? ?????...)

részek:
- depedency: kliens által igényelt szolgáltatás, amely a feladatának ellátásához szükséges
- dependant: a kliens objektum, amelynek szüksége van egy függőségre
- object graph: függő objektumok + függőségeik összessége
- injection: kliens függőségeinek megadása

(IOC (inversion of control) minta alkalmazásának speciális esete)

(DI/IOC Container): DI funkcionalitást nyújtó programkönyvtár

DI fajtái: setter, field, konstruktor

DI előnyei:
- karbantarthatóság
- tesztelhetőség
- kiterjeszhetőség

## Architekturális minták
-> szoftverrendszerek alapvető szerkezeti felépítésére adnak sémákat
alrendszerek + ezek felelősségi körei + irányelvek alrendszerek között
PL: mikrokernel, MVC

## MVC:
(model - view - controller)
környezet: ember-gép felülettel rendelkező interaktív alkalmazások
probléma: legyen a felhasználói felület könnyedén változtatható
megoldás: az interaktív alkalmazásokat 3 részre osztjuk:
model: adatok + funkcionalitások becsomagolása
view (nézet): információkat jeleníti meg a felhasználói felületen
controller (vezérlő): fogadja a bemenetet -> majd azt tovább adja a model vagy a view felé

![[Pasted image 20250216131720.png]]

### Tervezési minták
ezek design patterns-ek:
design pattern: középszintű minták, amelyek egy kisebb léptékű architekturális minta, cask egy alrendszer felépítését határozhatja meg, nem egy teljes szoftverrendszer felépítését

Minta: olyan problémát ír le, ami újra és újra felbukkan a környezetünkben, s aztán leírja hozzá a megoldás magját, oly módon, hogy a megoldás milliószor felhasználható legyen, anélkül, hogy valaha is kétszer ugyanúgy csinálnánk
minden minta 3 részből áll: környezet + probléma + a megoldás a problémára

(patternek fajtái:
- architectural patterns, architectural styles (ezek nem ugyanazok)
- design patterns
- programming idioms / implementatin patterns
- test patterns
- UI patterns
- antipatterns)

### Szabad szoftverek
Általános módon:
- tetszőleges célra használható
- működése szabadon tanulmányozható
- másolatait szabadon lehet terjeszteni
- szabadon módosítható

-> eltérő megközelítés a szabad szoftverre: Open source (nyílt forráskódú)
https://opensource.org/osd

alternatív elnevezés: FOSS: Free and Open Source software

### Nem szabad szoftverek.
A használat és terjesztés tilos, korlátozott vagy engedélyhez kötött
másnéven: zárt forrású kód (closed source), tulajdonosi szoftver (proprietery)

https://hu.wikipedia.org/wiki/Szabad_szoftver
http://sugo.ubuntu.hu/10.10/html/add-applications/hu/restricted-software.html

### Szoftverlicencek
-> szoftverek használatának és terjesztésének módját szabályozó jogi eszköz

### Szabad és nyílt forrású licencek fajtái

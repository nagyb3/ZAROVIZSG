```
Verziókezelés, verziókezelő rendszerek. Szoftvertesztelési alapfogalmak (tesztszintek, teszttípusok, teszttervezési módszerek). Objektum orientált tervezési alapelvek (GoF, SOLID). Függőség-befecskendezés. Architekturális minták (MVC). Tervezési minták. Szabad és nem szabad szoftverek. Szoftverlicencek, szabad és nyílt forrású licencek fajtái
```

archived: https://arato.inf.unideb.hu/jeszenszky.peter/swe/archive/2024/
- swe: https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/
## Verziókezelés
Pro Git:
- Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later.
A verziókezelő rendszerek lehetővé teszik, hogy a forráskódokban nyomonkövethessük az elvégzett változtatásokat
TODO GIT BRANCHES
TODO ELOSZTOTT verzió kezelő rendszer sajátossága
## verziókezelő rendszerek

## szoftvertesztelési alapfogalmak

https://arato.inf.unideb.hu/jeszenszky.peter/swe/presentations/hu/testing_hu.pdf

Mi a tesztelés?
->A szoftvertesztelés egy megoldás a szoftver minőségének
megállapításához és a szoftver működés közbeni meghibásodási
kockázatának csökkentésére

### **Tesztszintek:** a tesztelés különböző szinten végezhető a szoftverfejlesztési folyamatban
- egység / komponens teszt (unit test): egy darab egyedülálló komponens tesztelése, általában a komponens implementációja során kerül a unit test is megírásra a fejlesztő által
  - jó egység teszt: FIRST:
    - Fast
    - Independent
    - Repeatable
    - Self-validating: logikai kimenet kell hogy legyen
    - Timely: -> jó időben kerüljenek megírásra == a teszteket a kód megírása előtt készítsük el
  - AAA minta: (also: GivenWhenThen)
    - Arrange -> tesztelt rendszert egy adott állapotba juttatja el
    - Act -> tesztelt rendszer adott funkcióját meghívja
    - Assert -> kimenetel ellenőrzése
- komponens integrációs tesztelés (component / unit integration testing): integrált komponen kommunikációjára és interfészjeire fokuszál (done by the dev)
- rendszertesztelés: nem a dev-ek végzik, hanem független tesztelők a specifikációk alapján
- rendszer integrációs tesztelés: több rendszer közötti kommunikációnak a tesztelése és azoknak az interfészei (tesztelők felelősége)
- elfogadási tesztelés (acceptance test): ügyfél vagy rendszerüzemeltetők felelősége, annak a tesztelése, hogy egy szoftver megfelelőe a végleges átadásra a megrendelők számára
  - alfa tesztelés: felhasználók kis kiválasztott csoportja
    - fejlesztő szervezet helyén
  - béta tesztelés: reprezentatív felhasználók nagyobb halmaza
    - felhasználók helyén
    - marketing egy formája
    - főleg akkor jó, ha több környezetben is működnie kell az alkalmazásak

### **Teszttípusok:** tesztelés átfogó célja szerint. ezek bármelyike alkalmazható bármelyik tesztszintre
- funkcionális: annak tesztelése amit a rendszer csinál, funkciók tesztelése -> minden teszt szinten ajánlott végezni
- nem funkcionális: annak tesztelése, hogy a rendszer milyen jól működik
	  - pl használhatóság, teljesítmény vagy biztonság, stressz
- fekete dobozos
	- a rendszer belső működését nem ismerjük a tesztelés során
	- célja: rendszer működésének összevetése a specifikációval
- fehér dobozos:
	  - a rendszer belső felépítésén alapuló tesztelés
- változtatással kapcsolatos tesztelés: -> szükséges minden tesztelési szinten
	- megerősítéses tesztelés: a javított hiba megjavult-e
	- regressziós tesztelés: a kódbázisban elvégzett módosítás nem rontottak-e el valamit az eddig jól működő részeiben a rendszernek

### TESZTTERVEZÉSI MÓDSZEREK
• Tesztelő tapasztalata
• Specifikáció alapú
• Struktúra alapú (ismerjük a program felépítését)
• Hiba alapú (hibasejtés)
• Valószínűség (determinisztikus módon is lehet)

### Objektum orientált tervezési alapelvek

DRY (Don't Repeat Yourself)
KISS (Keep it simple studid)
YAGNI (You aren't going to need it)


## GoF (gang of four)
A GoF tervezési mintákat (design pattern-eket határzoknak meg)
Ezen tervezéis minták a következő könyvben lett meghatározva a 4 szerző által: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.
##### 1. Interfészre programozzunk, ne implementációra!

##### 2. Részesítsük előnyben az objektum-összetételt az öröklődéssel szemben!

GoF alapelvek céljuk szerint:
- létrehozási minta
- struktúrális/szerkezeti minta
- viselkedési minta

(eredetileg 23 mintát ír le a GOF könyv)


## SOLID
forrás Robert C Martin (Uncle Bob)
- **S**ingle Responsibility Principle -> egyszeres felelősség elv
  egy osztálynak csak egy oka legyen a változásra ????
- **O**pen / Closed Principle -> nyitva zárt elv
  szoftver entitások (pl osztályok) legyenek **nyitottak a kibővítésre**, de **zártak a módosításra**
  -> modul viselkedése kiterjeszthető, modul viselkedésének kiterjeszése nem eredményezi az seredeti osztály / modul eredeti forrás- vagy bináriskódjának változását
- Liskov's Substitution Principle -> liskov-féle helyettesítése elv
  forrás: Barbara Liskov
  -> Ha egy S típus egy másik T típusoknak az altípusa, akkor a programban úgy helyettesíthetjük a T típusú osztályokat az S típusú osztályokkal, hogy az nem változtatja meg a program működését
- Interfaces Segregation Principle -> interfész szétválasztás elv
  Az osztályokat nem szabad arra kényszeríteni, hogy olyan metódusoktól függjenek, amelyeket nem használnak
vastag interfész: "an interface with more methods and friends than that would be logically necessary"
ez az elv a vastag interfészeket -> ???. ....
interfész szennyezés: szükségtelen metódusok

- Dependency Inversion Principle -> Függőség megfordítás elv
  magas szintű modulok ne függjenek alacsony szintű moduloktól -> mindkettő absztrakciótól függjenek ?????

(hollywood elv: ne hívj majd mi hívunk)

## Függőség-befecskendezés
forrás: Martin Fowler

Az IoC (Inversion of Control) minta alkalmazása.
célja: achieving loosely coupled software
egy objektumra olyan szolgáltatásként tekintünk, amelyet kliensként használunk => kliens-szolgáltató viszony osztályok között (ez tranzitiv? ?????...)

részek:
- depedency: kliens által igényelt szolgáltatás, amely a feladatának ellátásához szükséges
- dependant: a kliens objektum, amelynek szüksége van egy függőségre
- object graph: függő objektumok + függőségeik összessége
- injection: kliens függőségeinek megadása

(DI/IOC Container): DI funkcionalitást nyújtó programkönyvtár

DI fajtái: setter, field, konstruktor

DI előnyei:
- karbantarthatóság
- tesztelhetőség
- kiterjeszhetőség

## Architekturális minták
-> szoftverrendszerek alapvető szerkezeti felépítésére adnak sémákat
alrendszerek + ezek felelősségi körei + irányelvek alrendszerek között
PL: mikrokernel, MVC

## MVC:
(model - view - controller)
környezet: ember-gép felülettel rendelkező interaktív alkalmazások
probléma: legyen a felhasználói felület könnyedén változtatható
megoldás: az interaktív alkalmazásokat 3 részre osztjuk:
model: adatok + funkcionalitások becsomagolása
view (nézet): információkat jeleníti meg a felhasználói felületen
controller (vezérlő): fogadja a bemenetet -> majd azt tovább adja a model vagy a view felé

![[Pasted image 20250216131720.png]]

### Tervezési minták
Angolul: design patternek.
-> középszintű minták, amelyek egy kisebb léptékű minta, csak egy alrendszer felépítését határozhatja meg, nem egy teljes szoftverrendszer felépítését

Minta: olyan problémát ír le, ami újra és újra felbukkan a környezetünkben, s aztán leírja hozzá a megoldás magját, oly módon, hogy a megoldás milliószor felhasználható legyen, anélkül, hogy valaha is kétszer ugyanúgy csinálnánk
minden minta 3 részből áll: környezet + probléma + a megoldás a problémára

TODO delete this BS
(minták fajtái:
- architectural patterns, architectural styles (ezek nem ugyanazok)
- design patterns
- programming idioms / implementatin patterns
- test patterns
- UI patterns
- antipatterns)

### Szabad szoftverek
Általános módon:
- tetszőleges célra használható
- működése szabadon tanulmányozható
- másolatait szabadon lehet terjeszteni
- szabadon módosítható

-> Nyílt forráskódú szoftverek (szabad szoftver és szabad szoft. inkább motivációbei különsége van mint gyakorlatbeli)

-> eltérő megközelítés a szabad szoftverre: Open source (nyílt forráskódú)
https://opensource.org/osd

alternatív elnevezés: FOSS: Free and Open Source software

### Nem szabad szoftverek.
A használat és terjesztés tilos, korlátozott vagy engedélyhez kötött
másnéven: zárt forrású kód (closed source), tulajdonosi szoftver (proprietery)

-> privát szoftver: egy adott cég vagy személyes kérésére készült egyéni szoftver -> a cég vagy egyén magának megtartja és nem teszi nyilvánossa


https://hu.wikipedia.org/wiki/Szabad_szoftver
http://sugo.ubuntu.hu/10.10/html/add-applications/hu/restricted-software.html

### Szoftverlicencek
-> szoftverek használatának és terjesztésének módját szabályozó jogi eszköz

### Szabad és nyílt forrású licencek fajtái
#### szabad:
->non-copyleft: **megengedő (permissive)**: minimális mértékben korlátoznak
		-> Pl Apache License 2.0, BSD licensek, MIT License
-> copyleft: "elidegenídhetetlen köztulajdon"
	Alkotás módosításait is ugyanolyan licensz alatt kell terjeszteni mint az eredetit
	pl: Emacs General Public License, GNU GPL 
#### nem szabad:
-> kereskedelmi szoftver
-> free ware: szabadon terjeszhetőek, de nem módosítható (forráskód sem elérhető)
-> shareware: szabadon terjeszthető, de használata feltételek mellett leheteséges, amelyek bevételt generálnak a szerzőnek

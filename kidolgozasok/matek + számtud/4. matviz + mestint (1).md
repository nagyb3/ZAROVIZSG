```
Függvények, görbék, felületek leírása és számítógépes ábrázolása.

Problémák reprezentálása állapottéren. A megoldás keresése visszalépéssel. Szisztematikus és heurisztikus fa- és gráfkereső eljárások
```


# matviz

### Függvények és görbék leírása
függvények:
egyértelmű hozzárendelést határoznak meg az értelmezési tartomány és az értékkészlet között 
[[matviz1ea.pdf]]

#### Explicit megadás:
->Polinomiális függvények
általános alakban:
![[Pasted image 20250427095749.png]]
- nulladfokú
	- f(x) = c
- elsőfokú: egyenesek rajzolása
	- f(x) = a x + c
- másodfokú: parabola
	- f(x) = b x^2 + a x + c

#### Implicit megadás:
(side note: ez már lehet, hogy technikailag nem fügvény)
itt egy x-nél több y is lehet-> maguk alá tudnak fordulni a görbék
alakjuk `F(x, y) = 0`

#### Paraméteres megadás


### Felületek leírása és számítógépes ábrázolása

#### explicit
F(x, y) = z

#### implicit
F(x, y, z) = 0

#### paraméter

[[Feluletek.pdf]]

---------------
# mestint (1)

### Problémák reprezentálása állapottéren
[[MI03.pdf]]
A lényege, hogy a megoldandó problémákat képesek vagyunk absztrakt módon leírni, így megkönnyítve azok megoldásainak keresését.
Problémák reprezentálása állapottéren a következő elemek megadásával történik:
$$
< A \space a_0 \space c \space O >
$$
A: az össze érvényes állapot, amelyet megoldandó probléma felvehet
a_0: a kezdő állapot: innen indulunk a probléma megoldása előtt
c: célállapot/célteszt: he ide eljutunk akkor tekintjük megoldottnak a problémát
o: operátorok vagy **ÁLLAPOT ÁTMENET FÜGGVÉNYEK**: ezek felhasználsával képesek vagyunk a problémát egyik állapotából egy másik állapotába

A problémák állapottéren történő reprezentálásának egy legegyszerűbb példája a porszívó világa.
- Állapotok: kosz és robot helyzete
- Műveletek: a robot jobbra megy, balra megy, takarít vagy NoOp
- Célteszt: Nem maradt egyik mezőn sem kosz
![[Pasted image 20250514142025.png]]

## A megoldás keresése visszalépéssel
A visszalépéses keresőt a kényszerkielégítése feladatoknál alkalmazott mélységi keresés, amely minden szintnél hozzárendel egy változóhoz egy értéket.

naiv: azért "visszalépés" megoldás keresés, mert ha eljutunk a keresés közben egy olyan pontra ahonnan már tudjuk, hogy nem fogunk megoldást találni (pl elfogytak a lehetséges adható értékek), akkor a kiterjesztést leállítjuk ott és egy másik ágon folytatjuk azt.
### Kényszer kielégítési problémák:
Olyan problémákat írnak, le ahol az állapot változókat tartalmaz, ezekhez a változókhoz értékeket szeretnék rendelni és változó értékeire szeretnék bizonyos kényszerek alkalmazni.

Például: térkép színezési probléma, ahol a területhez szeretnék színeket rendelni olyan módon, hogy az egymással szomszédos területeknek ne legyen azonos a színe. (ez egy bináris kényszert határoz meg ahol x1 != x2)

Felírhatjuk a problémánkra a kényszergráfot is, amely egy gráfban tárolja el a változókat, az élek a változók között fennálló kényszereket jelölik.

Ezeknek a változóknak az értékeire alkalmazunk valamilyen fajta kényszereket, amelyeket teljesíteni kell
A kényszerek lehetnek:
- unáris (pl x1 != zöld)
- bináris x1 != x2
- többed fokú kényszerek (több mint 2 változó között áll fenn)

**Kényszer kielégítési problémák (standard) inkrementális keresési módszere**:
- állapotok a már értékkel rendelkező változók adják meg
- kezdeti állapot: egyik változónak sincs értéke
- rákövetkező függvény: értéket rendelünk egy változóhoz, amelynek még nincsen értéke olyan módon, hogy betartsuk a kényszereket
- célteszt: minden változó kapott-e értéket, és az értékeke kielégítik-e a kényszereket

A visszalépéses keresés közben az általános keresési módszert jelentősen felgyorsíthajtuk, ha a kiterjesztések előtt megfontosljuk a következő kérdéseket:
	- Mely legyen a következő változó, amely értéket kap
	- Az értékekeket milyen sorrendben próbáljuk ki
	- Korán fel tudjuk ismerni az elkerülhetetlen hibákat? ***???***
	- Felhasználhatjuk a feladat szerkezetét? **???**
#### Stratégiák, amelyeket felhasználhatunk a visszalépéses keresés hatékonyságának növeléséhez  
- Legkevesebb fennmaradó érték: az a változó kapjon következőnek értéket, amely a legkevesebb "megengedett" értékkel rendelkezik
![[Pasted image 20250514134140.png]]
LEGKEVESEBB FENNMARADÓ ÉRTÉKEK HOLTVERSENYÉNEK MEGOLDÁSA: **Fokszám heurisztika**
![[Pasted image 20250514134208.png]]
- Legkevésbé korlátozó érték
![[Pasted image 20250514134241.png]]
- Előrenéző ellenőrzés: Amennyiben egy változónál már nem maradhat adható érték, akkor leállítjuk a keresést 
![[Pasted image 20250514172035.png]]
- **Kényszerek terjesztése**
- **Élkonzisztencia**: 
("tovább terjeszti a kényszereket")
![[Pasted image 20250514172509.png]]
![[Pasted image 20250514172528.png]]

[[MI05.pdf]] 12. oldal
### Szisztematikus és heurisztikus fa- és gráfkereső eljárások
### Szisztematikus (nem informált) keresesési eljárások
A szisztematikus keresések nem használnak heurisztikát, amellyel képesek lennének kiértékelni, hogy a csúcsokat mennyire vannak közel a célállapothoz.
Csak a kezdeti állapot és az alkalmazható operátorok alapján képes dolgozni.
- szélességi keresés: legkisebb mélységűt nézzük meg, amelyet nem terjesztettük még ki
![[Pasted image 20250514143519.png]]
- mélységi keresés: a legmélyebb még nem kiterjesztett csúcsot terjesszük ki
![[Pasted image 20250514143600.png]]
- Mélység korlátozott keresés: olyan mélységi keresés, amelyben megadjuk a maximális mélységet
- Iteratívan mélyülő mélységi keresés: olyan mélységi keresés, amelyben egy adott "körben", a jelenleg meghatározott max mélységig keres. Amint kiterjesztette az adott mélységig lévő összes csúcsot, akkor növeli a max mélységet
#### Szisztematikus gráf kereső

## Heuriszitkus kereső:
- alapötlet: használjunk egy kiértékelő függvényt, amely a csúcsokra megmodja, hogy a csúcs "mennyire kívánítos", például az út kereső algoritmusoknál, hogy az adott város milyen messze van a célponttól
- => a legkívánatosabbat terjeszjük ki következőnek
### Mohó legjobbat előszőr
`h(n)` kiértékelő függvényt használ -> heurisztika
-> útvonal kereső feladatoknál megbecseüli a posnt távolságát a céltól

NEM TELJES, mivel képes beragad, ha kicsi heurisztikája csúcsokat talál
NEM OPTIMÁLIS
### A* keresés
alapötlet: ne terjesszük ki azokat az utakat, amelyek már alapból drágák
kiértékelő függvény amelyet használunk a csúcsoknál:
`f(n) = g(n) + h(n)`
g(n) -> útköltség n pontig
h(n) -> a célig tartó út becsült költsége
f(n) -> az n-en keresztül a célbe vezető út becsült teljes költsége <= ez lesz az az érték, amely a csúcsnak adunk és majd használunk a kiterjesztések meghatározásához
- legkisebb f(n) értékűt válaszjuk a kiterjesztéshez
### Minimax
Játékok kontextusában használjuk.


### Alfa béta vágás
Megj. Konzisztens heuriszitka fogalma:
![[Pasted image 20250514144551.png]]

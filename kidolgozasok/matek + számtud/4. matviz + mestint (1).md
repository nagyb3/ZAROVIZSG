```
Függvények, görbék, felületek leírása és számítógépes ábrázolása.

Problémák reprezentálása állapottéren. A megoldás keresése visszalépéssel. Szisztematikus és heurisztikus fa- és gráfkereső eljárások
```
# matviz

### Függvények és görbék megadási módjai
Függvények általános fogalma:
A függvények egyértelmű hozzárendelést határoznak meg az értelmezési tartomány és az értékkészlet között.

Egy A -> B hozzárendelés akkor egyértelmű, ha nem fordul elő, hogy egy A-beli elemhez több B beli elem lenne hozzárendelve.
![[Pasted image 20250516173259.png]]
[[matviz1ea.pdf]]
#### 1. Görbék megadása explicit függvény
Ez az egyetlen görbe megadási mód az említettek közül, amely tényleges függvény, mivel minden x értékhez csak legfeljebb egy y értéket rendel.
Az explicit függvényeket általános módon a következő alakban tudjuk megadni:
$$
y = f(x)
$$
Ezeknek a számítógéppel való kiszámítása nagyon hatékony (? miért?)

Amennyiben egy függvénynek van képlete akkor meg kell adnom azt is, hogy milyen halmazokra értelmezem azt:
$$
\mathbb{R} \rightarrow \mathbb{R}
$$

Megj példák:
->Polinomiális függvények
általános alakban:
![[Pasted image 20250427095749.png]]
- nulladfokú
	- f(x) = c
- elsőfokú: egyenesek rajzolása
	- f(x) = a x + c
- másodfokú: parabola
	- f(x) = b x^2 + a x + c

#### 2. Implicit görbék:
Ezek közül vannak már olyanok, amelyek technikailag nem függvények. Akkor nem függvények, ha egy x értékhez több y értéket is hozzárendelünk.
Általános alakjuk:
$$
F(x, y) = 0
$$
#### 3. Görbék paraméteres megadása
Itt az értelmezési tartomány egy intervallum lesz, amelyet az t paraméter "befut".
Felhasználunk egy bizonyos paramétert, amelyet általában t-vel jelölünk.
->x-et és y-t is 1-1 parametrikus függvény meghatározásával adjuk meg.
$$
x = f(t)
$$$$
y = g(t)
$$

#### 4. Bezier-görbe
Ennél a görbe megadási módnál kontroll pontokat adunk meg (általános esetben 4-et).
Az első és az utolsó kontrollpont mindenképpen a görbe végpontja lesznek, a többi kontrollpontot a görbe megközelíti.s
![[Pasted image 20250516183237.png]]
![[Pasted image 20250516180849.png]]

#### 5. Hermite-ív
Itt pontokat adunk meg és a pontokhoz érintő vektorokat.
![[Pasted image 20250516183219.png]]
## Felületek leírása és számítógépes ábrázolása
#### 1. Felületek megadása explicit alakban
$$
F(x, y) = z
$$
Explicit megadással nem vagyunk képesek olyan felületet meghatározni, amely "maga alá görbülne"

![[Pasted image 20250516183106.png]]
#### 2. Felületek megadása implicit alakban 
$$
F(x, y, z) = 0
$$
Ezzel lehet már "maga alá görbülő" felületet csinálni
![[Pasted image 20250516183127.png]]
#### 3. Felületek megadása paraméteres alakban
![[Pasted image 20250516183154.png]]
[[Feluletek.pdf]]

---------------
# mestint (1)

### Problémák reprezentálása állapottéren
[[MI03.pdf]]
A lényege, hogy a megoldandó problémákat absztrakt módon írjok le, minden implementációs részletet elrejtve. Ezen absztrakt leírás felhasználásval a célunk, hogy a problémákra minél hatékonyabban megtaláljuk a megoldást (több megoldás közül 1-et)

Problémák reprezentálása állapottéren a következő elemek megadásával történik formálisan:
$$
< A \space a_0 \space c \space o >
$$
A: az össze érvényes állapot, amelyet megoldandó probléma felvehet
a_0: a kezdő állapot: innen indulunk a probléma megoldása előtt (a_o eleme A-nak)
c: célállapot: he ide eljutunk akkor tekintjük megoldottnak a problémát
- A célállapotok megadhatjuk a célállapotok felsorolásával, vagy egy célteszt meghatározásával, amellyel eltudjuk dönteni egy állapotról, hogy cél-e
o: operátorok vagy **ÁLLAPOT ÁTMENET FÜGGVÉNYEK**: ezek felhasználsával képesek vagyunk egy állapotot egy másik állapotba átvinni
	például: porszívó menjen jobbra

megj: A problémák állapottéren történő reprezentálásának egy legegyszerűbb példája a porszívó világa.
- Állapotok: kosz és robot helyzete
- Műveletek: a robot jobbra megy, balra megy, takarít vagy NoOp
- Célteszt: Nem maradt egyik mezőn sem kosz
![[Pasted image 20250514142025.png]]

## A megoldás keresése visszalépéssel
A visszalépéses keresőt a kényszerkielégítési feladatoknál alkalmazott mélységi keresés, amely minden szintnél (vagyis állapotátmenet alkalmazásával) hozzárendel egy értéket egy változóhoz.
A keresés kezdeti állapota: változóknak nincsen értéke, innentől adunk hozzá a keresés során értékeket az egyes változóknak.

naiv: azért "visszalépés" megoldás keresés, mert ha eljutunk a keresés közben egy olyan pontra ahonnan már tudjuk, hogy nem fogunk megoldást találni (pl nem tudunk már úgy egy változónak sem értéket adni, hogy kielégítsük a kényszereket), akkor a kiterjesztést leállítjuk és egy másik ágon folytatjuk tovább a keresést.
### Kényszer kielégítési problémák:
Olyan problémákat írnak, le ahol az állapot változókat tartalmaz, ezekhez a változókhoz értékeket szeretnék rendelni és változó értékeire szeretnék bizonyos kényszereket alkalmazni.

Például: térkép színezési probléma, ahol a területhez szeretnék színeket rendelni olyan módon, hogy az egymással szomszédos területeknek ne legyen azonos a színe. (ez egy bináris kényszert határoz meg ahol x1 != x2)

Felírhatjuk a problémánkra a kényszergráfot is, amely egy gráfban tárolja el a változókat, az élek a változók között fennálló kényszereket jelölik. (lásd lenti ábra jobb oldali gráf)

![[Pasted image 20250514190741.png]]

A változóknak az értékeire alkalmazunk valamilyen fajta kényszereket is, amelyeknek az állapotoknak meg kell felelnie.
A kényszerek lehetnek:
- unáris (pl x1 != zöld)
- bináris x1 != x2
- többed fokú kényszerek (több mint 2 változó között áll fenn)

**Kényszer kielégítési problémák (standard) inkrementális keresési módszere**:
- állapotok a már értékkel rendelkező változók adják meg
- kezdeti állapot: egyik változónak sincs értéke
- rákövetkező függvény: értéket rendelünk egy változóhoz, amelynek még nincsen értéke olyan módon, hogy betartsuk a kényszereket
- célteszt: minden változó kapott-e értéket, és az értékeke kielégítik-e a kényszereket

A visszalépéses keresés közben az általános keresési módszert jelentősen felgyorsíthajtuk, ha a kiterjesztések előtt megfontosljuk a következő kérdéseket:
	- Mely legyen a következő változó, amely értéket kap
	- Az értékekeket milyen sorrendben próbáljuk ki
	- Korán fel tudjuk ismerni az elkerülhetetlen hibákat? ***???***
	- Felhasználhatjuk a feladat szerkezetét? **???**
#### Stratégiák, amelyeket felhasználhatunk a visszalépéses keresés hatékonyságának növeléséhez
#### Változó választási heurisztika:
- Legkevesebb fennmaradó érték: az a változó kapjon következőnek értéket, amely a legkevesebb "megengedett" értékkel rendelkezik
![[Pasted image 20250514134140.png]]
LEGKEVESEBB FENNMARADÓ ÉRTÉKEK HOLTVERSENYÉNEK MEGOLDÁSA: **Fokszám heurisztika**
![[Pasted image 20250514134208.png]]

#### Értékválasztási heurisztika (itt azt döntjük el, hogy az állapotátmenet milyen értéket adjon egy változónak)
Legkevésbé korlátozó érték (Least constraining value LCV)
![[Pasted image 20250514134241.png]]

#### Kényszerek propagálása (<- chatgpt said!)
->**Előrenéző ellenőrzés**: Nyomon követjük, hogy a változóknak milyen fennmaradó értékeik vannak még. Amennyiben egy változónál már nem maradhat adható érték, akkor leállítjuk a keresést
(itt az alsó táblázat felülről lefelé értelmezendő)
![[Pasted image 20250514211636.png]]

![[Pasted image 20250514211750.png]]
->**Élkonzisztencia**: minden élt konzisztenssé teszünk
Egy X -> Y él akkor konzisztens, ha elmondhatjuk róla azt, hogy X minden x értékéhez, Y változónak van egy y értéke úgy, hogy az X és Y közötti kényszer teljesüljön.
![[Pasted image 20250514172509.png]]
![[Pasted image 20250514172528.png]]
![[Pasted image 20250514213100.png]]
![[Pasted image 20250514213113.png]]
[[MI05.pdf]] 12. oldal
### Szisztematikus és heurisztikus fa- és gráfkereső eljárások

### Szisztematikus (nem informált) keresesési eljárások
A szisztematikus keresések nem használnak heurisztikát, amellyel képesek lennének kiértékelni, hogy a csúcsokat mennyire vannak közel a célállapothoz.
Csak a kezdeti állapot és az alkalmazható operátorok alapján képes dolgozni.
- Szélességi keresés: legkisebb mélységűt nézzük meg, amelyet nem terjesztettük még ki
![[Pasted image 20250514143519.png]]
- mélységi keresés: a legmélyebb még nem kiterjesztett csúcsot terjesszük ki
![[Pasted image 20250514143600.png]]
->Mélység korlátozott keresés: olyan mélységi keresés, amelyben megadjuk a maximális mélységet

->Iteratívan mélyülő mélységi keresés: olyan mélységi keresés, amelyben egy adott "körben", a jelenleg meghatározott max mélységig keres. Amint kiterjesztette az adott mélységig lévő összes csúcsot, akkor növeli a max mélységet

#### Szisztematikus gráf kereső
## Heuriszitkus kereső:
- alapötlet: használjunk egy kiértékelő függvényt, amely a csúcsokra megmodja, hogy az adott csúcs milyen messze van a cél célállapottól
- => a legkívánatosabbat (legközelebb lévőt a célállapothoz) terjeszjük ki következőnek
### Mohó legjobbat előszőr
`h(n)` kiértékelő függvényt használ -> heurisztika
-> útvonal kereső feladatoknál megbecseüli a posnt távolságát a céltól

NEM TELJES, mivel képes beragadni, ha olyan csúcsot talál amely "közel van a célállapothoz", de nem vezető belölő út kisebb értékbe vagy a célállapotba
NEM OPTIMÁLIS ?
### A* keresés
alapötlet: ne terjesszük ki azokat az utakat, amelyek már alapból drágák
kiértékelő függvény amelyet használunk a csúcsoknál:
`f(n) = g(n) + h(n)`
g(n) -> útköltség n pontig
h(n) -> a célig tartó út becsült költsége
f(n) -> az n-en keresztül a célbe vezető út becsült teljes költsége <= ez lesz az az érték, amely a csúcsnak adunk és majd használunk a kiterjesztések meghatározásához
- legkisebb f(n) értékűt válaszjuk a kiterjesztéshez

->! Akkor elfogadható egy heurisztika ha a heurisztika alábecsüli a tényleges értéket

A* keresés tulajdonságok:
- teljes

Megj. Konzisztens heuriszitka fogalma:
![[Pasted image 20250514144551.png]]



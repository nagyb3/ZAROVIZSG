```
Mátrix fogalma, műveletek, determináns, rang. Speciális mátrixok, inverz. Mátrix, mint lineáris transzformáció. Sajátérték, sajátvektor.

Intelligens ágensek, ágensek típusai, ágensek környezetét leíró tulajdonságok. Markov döntési folyamatok és adaptív dinamikus programozás alapú ágens, Időbeli különbség (TD-temporal difference) alapon hasznosságot tanuló ágens. Aktív megerősítéses tanuló ágens, felfedezés és kihasználás (exploration és exploitation) módszere. Q-tanuló ágens.
```
# diszkmat (1)
[[ea_08.pdf]]
### Mátrix fogalma
Egy m sorral és n oszloppal rendelkező számtáblázatot m x n -es mátrixnak nevezünk.
![[Pasted image 20250423165418.png]]
![[Pasted image 20250528123642.png]]

Legfontosabb általáos fogalmak mátrixokhoz kapcsolódóan:
	- főátló
	- sorok száma: m
	- oszlopok száma: n
	- kvadratikus: a sorok száma megegyezik az oszlopok számával (vagyis m = n)

### műveletek:
- Mátrix összeadás
![[Pasted image 20250423170936.png]]
Vagyis: a mátrix összeadás során azonos dimenzióval (sorok száma és oszlopok száma) rendelkező mátrixokat tudunk összeadni.
A mátrix összeadás elemenként történik.


- Skalárral való szorzás:
![[Pasted image 20250423170943.png]]
A mátrixok skalárral való szorzását elemenként végezzük, amely során minden elemet megszorzunk a skalárral. A skalár jelölése **λ** (lambda)

- Mátrixok szorzás
![[Pasted image 20250423165938.png]]

A mátrixok szorzásánál fontos, hogy A és B mátrixok szorzata egy m x n-es mátrix lesz.
A oszlopainak a számának egyenlőnek kell lennie B mátrix sorainak a számával, vagyis:
A: m x k-es
B: k x n-es

ekkor C : m x n -es lesz (ez lesz az eredmény)

![[Pasted image 20250423170020.png]]


- Mátrix transzponálás
 ![[Pasted image 20250423170032.png]]
=> A^t sorai A-nak oszlopai !
naiv: főátlóra megtükrözzük a mátrixot
mátrix transzponálás jelölése:
$$
A^t
$$


Megjegyzés a mátrix transzponáláshoz: szimmetrikusság ! :
![[Pasted image 20250528124156.png]]
Vagyis: akkor szimmetrikus egy mátrix, ha a főátlóra szimmetrikus

Példa ferdeszimmetrikus mátrixra:
$$
A = \begin{bmatrix}
0 & 2 & -1 \\
-2 & 0 & 4 \\
1 & -4 & 0
\end{bmatrix}

$$

### Determináns:
https://www.youtube.com/watch?v=Ip3X9LOh2dk&t=149s

Fontos a deteriminást csak KVADRATIKUS mátrixokon értelmezzük !

![[Pasted image 20250528150207.png]]
![[Pasted image 20250528150222.png]]
#### Determináns kiszámításának módjai:
- **sarrus szabály:** fő átlók és azzal párhuzomasok szorzata - mellék átlok és azzal párhuzamosak szorzata
- **gauss-elimináció** (megj: sorcserék mindegyike -1 -el szorozza meg a determinánst)
- **Kifejtési-tétel**: https://hu.wikipedia.org/wiki/Kifejt%C3%A9si_t%C3%A9tel
	- kiválasztunk egy sort
	- (megj: sakk tábla szabály)
	- adott sorunk végig megyünk:
		- az elem sorát és oszlopát kivesszük a mátrixokból és a fennmaradó aldeterminánst kiszámoljuk 
		- érték * aldet * (1 / -1 a sakk tábla szabály alapján)
		- <- ezeknek az összege adja ki a teljes mátrix determinánsát

nevezetes mátrixok determinánsa:
- felső háromszög és diagonális mátrixban: főátló elemeinek a szorzata
- egységmátrixnak: 1
- nullmátrix: 0

megj: Sarrus-szabály alkalmazására quick példa:
A = [2 3 5
	4 1 2
	3 5 7]
$$
det(A) = 2 * 1 * 5 + 3 * 2 * 3 + 5 * 4 * 5 - 5 * 1 * 3 - 3 * 4 * 7 - 2 * 5 * 2 
$$
- gauss elimináció -> felsőháromszög mátrix
![[Pasted image 20250427111034.png]]
![[Pasted image 20250427111015.png]]

![[Pasted image 20250528124806.png]]
### Rang:
![[Pasted image 20250421222613.png]]
megj: Lineárisan független oszlop és soroknak a számát adja meg, vagyis a mátrix oszlop vektorai által meghatározott altér rangját

megj: a rang-kritéirum használhatjuk fel ahhoz, hogy eldöntsük egy lineáris egyenletrendszernek van-e megoldása, hiszen ha rang(A) = rang(A|b) akkor megolható a lineáris egyenletrendszer.

### Speciális mátrixok
#### 1, Egység mátrix
-> olyan nxn-es mátrix, amelynek a főátlójában 1-esek vannak és a többi eleme 0
Jelölése:
$$
I_n
$$
vagy
$$
E_n
$$
Példa:
$$

E_3 = \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}

$$

#### 2, felső háromszög mátrix
- szimmetrikus mátrix mátrix
$$
A^t = A
$$
#### 3, diagonális mátrix:
- olyan kvadratikus mátrix, amelynek a főátló kívüli elemei 0-ák, a főátló beli elemei pedig nem 0-ák
#### 4, nullmátrix
-> minden eleme 0
##### 5, egymátrix
minden eleme: 1
#### 6, ortogonális mátrix 
- Az A mátrix transzponáltja, az A mátrix inverze
A ortogonális, ha:
$$
A*A^t = A^T * A =  E 
$$
#### 7, szimmetrikus mátrix (lentebb)
#### 8, ferdeszimmetrikus
![[Pasted image 20250528124156.png]]

### Mátrix inverze
![[Pasted image 20250423165834.png]]
Fontos: csak akkor invertálható a mátrix, ha reguláris (vagyis determinánsa nem 0), illetve a mátrix KVADRATIKUS

### Mátrix mint lineáris transzformáció
Ebben a forrásban van benne 15. oldaltól: [[Matek_5.pdf]]

Naivan egy leképzés: vesz egy vektort és átalakítja egy másik vektorrá
![[Pasted image 20250528131153.png]]
naivan: Ax = w
vagyis w = T(x) <- T mivel Transformation

Rn -> Rm -be képez a leképzés

![[Pasted image 20250528131209.png]]
ϕ: fí

Ahhoz, hogy a V-ből W vektortérbe való leképzés lineáris leképzés legyen, teljesítenie kel a additivitást és a homogenitást

Egy lineáris leképzés akkor lesz LINEÁRIS TRANSZFORMÁCIÓ, ha V és W vektorterek egyenlőek (A lineáris leképzés V vektortérből képez W vektortérbe)

Akkor a lineáris transzformációt egy olyan mátrix fogja leírni amely kvadratikus (vagyis m = n,
n x n -es mátrix)

[[09_sajatertekGYAK.pdf]]
### Sajátérték, sajátvektor
(megj: angolul eigenvalue, eigenvector)
[[ea_10.pdf]] (15. oldaltól)

Naivan: a sajátvektor egy olyan vektor, amelynek nem változik meg az iránya egy adott lineáris transzformáció "alapján"

A sajátvektorokhoz megadhatjuk, hogy ez a vektor mekkora arányba fog skálázódni a lineáris transzformáció végrehajtása során: ez lesz a sajátérték (skalár)

huge megj: skalár, mint scalár, vagyis skálázó, azt csinálja, hogy egy adott mátrixot "skálázz".


ELSŐ DEFINÍCIÓ KÖVETKEZŐ DIÁN:
vagyis egy nem nulla v vektorhoz, létezik olyan lambda érték, hogy
$$
\varphi(v) = \lambda * v
$$
teljesül

![[Pasted image 20250528144629.png]]
![[Pasted image 20250423141707.png]]

-> Legyen adott A n x n -es mátrix. Ennek az A vektornak x a sajátvektora, ha létezik egy λ (lambda) skalár úgy, hogy igaz legyen a következő:
$$
Ax = \lambda x
$$
=> Ekkor λ a **sajátérték**
=> Ekkor x a **sajátvektor**


-----------
# mestint (2)
### Ágensekről általában
[[MI01.pdf]] 9. oldal
- absztrakt módon azt mondhatjuk, hogy **az ágens egy olyan függvény, amely az érzékelések sorozatához egy cselekvést rendel**
$$
	f: P^* \rightarrow A
$$
P: percepciók, vagyis megfigyelések (P* a cselekvések sorozatát jelenti)
A: action: cselekvések

Alapvetően azt is elmondhatjuk, hogy egy ágens egy elméleti konstrukció, amelyet az ágens program fog ténylegesen megvalósítani. Az ágens program fog tényleges fizikai architektúrán futni.

### Intelligens ágens
Egy ágens attól lesz intelligens ágens, hogy van egy teljesítménymértéke (ez a teljesítmény érték a környezet adott állapotát értékeli) és a lehetséges cselekvések közül azt fogja kiválasztani, amelyik a legjobb várható teljesítményértékkel rendelkezik.

- racionális (? == intelligens ágens): olyan ágens, amely a legjobb várható eredmény iránt cselekszik (a környezete alapján) 


Egy intelligens ágens megterezésekor fontos a feladat környezetének pontosítása, vagyis a TKBÉ négyes meghatározása (példák a robottaxi TKBÉ-jére):
	- Teljesítménymérték
		- pl robottaxi: szabálykövetés, út ideje
	- Az ágens KÖRNYEZETE
 		- pl robottaxi: a város, lámpák, táblák
	- Beavatkozók: mik azok az eszközök amelyekkel az ágens végretudja hajtani a cselekvéseit
 		- pl robottaxi: pedálok, kormány
	- Érzékelők: mik azok az eszközök, amelyekkel az ágens képes információkat megtudni a környezetéről
		- pl: robottaxi: kamera, sebességmérő
	
=> az ágens a környezetével a szenzorok (megfigyelésekhez) és a beavatkozók (cselekvéseknél) felhasználásával lép interakcióba

[[MI02.pdf]]
## Ágensek típusai:

### Egyszerű reflexszerű ágens
![[Pasted image 20250518121936.png]]
Az egyszerű reflexszerű ágens ha-akkor utasításokra épít, vagyis a szenzorok megfigyelései alapján if-else utasításokkal dönti el a következő cselekedetét.
(ha a feltétel teljesül, akkor végrehajtódik a cselekvés)

[[példa program egyszerű reflexszerű ágensre]]

### Modellalapú reflexszerű ágens
![[Pasted image 20250518122124.png]]
A modell alapú reflexszerű ágens rendelkezik egy belső modellel amellyel nyomonkövi a környetének állapot. Ezen a modellen futtat le ha-akkor kiértékeléseket és ez alapján hozzá meg a következő cselekedetét.

[[példa program modellalapú ágensre]]

### Célorientált ágens
![[Pasted image 20250518122338.png]]
Ez is rendelkezik egy modellel a környezetről, de ez már nem tartalmazza a szabályokat "beégetve". A ha-akkor szabályok helyett célokat tartalmaz.
Figyelembe veszi a következőket:
- környezet jelenlegi állapota (érzékelőkön keresztül értesül ezekről)
- a lehetséges cselekvések milyen eredménnyel lennének a környezet jelenlegi állapotára
=> ezen szempontok alapján dönt a céljanak legjobb cselekvés mellett

A hasznosság orientált (következő alpont..) ágenssel összehasonlítva a célorientált ágenst csak azt vizsgálja meg, hogy olyan cselekvést válasszon amely *valamilyen* módon elvezeti a célállapotba.

### Hasznosságorientált ágens
![[Pasted image 20250518122351.png]]
Szintén rendelkezik egy állapottal, amelyet frissít az érzékelőkön megkapott információk alapján.
Megvizsgálja mit okozna a cselekvése.
	Ezek után a HASZNOSSÁG szem előtt tartva dönt. A hasznosság a következő kérdésre ad választ: "Milyen boldog leszek egy ilyen állapotban?" vagyis hogy az adott állapot mennyire kívánatos ha az optimális utat keresem a célhoz.

==> Nem csak az érdekli, hogy elérünk-e a célba hanem, hogy OPTIMÁLISAN érünk-e el a célba!!

naivan: a hasznosságorientált függvények azt is értékelik, hogy egy adott állapot mennyire "kívantos" például a legrövidebb utat keressük, vagy a legolcsóbb utat keressük.

### Tanuló ágens
![[Pasted image 20250518122403.png]]
A tanuló ágensnek van egy kívülről kapott "teljesítményszabvány"-a.

Részei:
- végrehajtó elem: ez az elem fogja meghatározni a következő cselekvését az ágensnek
- tanuló elem: a kritikustól fogadja a visszacsatolást (vagyis hogy mennyire volt jó az előző cselekvés) és változásokat hoz létre példaul megváltoztatja a hasznosság függvényt, a változtatásokat a végrehajtó elemen hozza létre
- kritikus: megmondja a tanuló elemnek az érzékelések és a teljesítményszabvány alapján, hogy az ágens mennyire jól teljesített
- probléma generátor: új kihívásokat generál az ágensnek amelyekből tanulhat (pl felfedezés és kihasználás) 

### Ágensek környezetét leíró tulajdonságok:
- Megfigyelhetőség: teljesen/részben megfigyelhető a környezet
	- ez azt jelenti, hogy képesek vagyunk-e a teljes környezetet mefigyelni egy adott időpillanatban
	- pl: sakk teljesen megfigyelhető, robottaxi részben megfigyelhető
- Determinisztikusság: 
	- ez azt jelenti, hogy a következő állapotot egyértelműen meghatározza-e a jelenlegi állapot, illetve az ágens cselekedete
	- lehet:
		- determinisztikus -> igen
		- sztochasztikus -> nem
		- stratégia -> igen, determinisztikus, de jelen vannak más ágensek is
		Pl : sakk determinisztikus, a robottaxi sztochasztikus környezettel rendelkezik
- Epizódszerű / sorozatszerű
	- Az **ágens tapasztalta atomi epizódokra bontható**, ahol minden epizód érzékelésekből és cselekvésekből áll. **Az epizódok függetlenek egymástól**.
	- Példa epizódszerűségre: egy futaszalagon jönnek a termékek a robot felé és a robot felismer rajtuk valamilyen információt. Itt a különböző termékek észlelése a futószalagon nincsenek egymással hatással.
	- A robottaxi sorozatszerű
- Statikus / dinamikus:
	- statikus: a környezet nem változik meg ameddig az ágens gondolkozik
	- dinamikus: miközben az ágens gondolkozik, addig a környezete megváltozhat
	- szemidinamikus: az idő múlása nem az ágens környezetére van hatással, hanem az ágens teljesítménymértékére
		- példa szemidinamikussághoz: étel kiszállításnál a környezet nem változik meg ameddig az ágens gondolkozik, de a teljesítménymérték (hogyan mennyire jó volt a kiszállítása), csökken (mivel az étel kihűl vagy megromlik akár)
- Diszkrét / Folytonos:
	- A környezet szerkezete, az idő múlása, ágens észleléseinek/cselekedeteinek szerkezete reprezentálható-e EGÉSZ SZÁMOKKAL
- Egy / Többágenses (ágensek száma): mennyi ágens van egyszerre a környezetben?
	- Amennyiben több ágens van, akkor ezek az ágensek lehetnek egymással egyszerre kooperatívak vagy versengőek.

// INNENTŐL REINFORCMENT LEARNING-ról van szó:
másik jó forrás: https://lilianweng.github.io/posts/2018-02-19-rl-overview/
#### Megerősítéses tanulás:
A megerősítés tanulás azzal foglalkozik, hogy miként cselekedjen az ágens, hogy maximalizálja az összjutalmat?
- A legfontosabb itt, hogy az ágens a cselekedetei után jutalmat kap ("reward") -> az ágensnek az a célja, hogy ennek összegét maximalizálja.
![[Pasted image 20250517173827.png]]
![[Pasted image 20250517174115.png]]


https://www.youtube.com/watch?v=NFo9v_yKQXA
#### Markov tulajdonság:
Minden állapot csak az őt közvetlenül megelőző állapottól függ.

### Markov döntési folyamatok
MDP (Markov's decission process)

Magyarul mire jó az MDP:
A Markov döntési folyamat az alap, amelyre a megerősítéses tanulás épül. Segítségével pontosan és matematikailag kezelhető módon modellezhető, hogyan tanul egy ágens a környezetből érkező visszajelzések alapján, miközben hosszú távú célokat követ.
A Markov döntési folyamat adja meg a formális keretet, amiben egy tanuló ágens (pl egy robot) döntéseket hoz és tanul a környezetből kapott visszajelzések alapján.

==> Vagyis a markov döntési folyamat egy formális modell, amely egy matematikai keretet ad meg a környezet leírásához.

https://www.youtube.com/watch?v=2iF9PRriA7w
[[combined_RL.pdf]]  37. oldal
![[Pasted image 20250517173738.png]]

**Markov döntési folyamat:**
`(S, A, R, P, γ)`:
- S: States: Állapotok
- A: Actions: Cselekvések
- R: Reward function: jutalom függvény
- P: Állapot átmenet valószínűségek
- γ (kis gamma): discount factor
$$
\gamma \in [0, 1]
$$
A discount factor minél nagyobb annál jobban fogjuk figyelembe venni a későbbi (hosszú távú) jutalmakat is, a rövid távúakkal szemben.

Minél kisebb a discount factor, annál jobban csak a rövid távú jutalmakat vesszük figyelembe.


jó video talán ide?
https://www.youtube.com/watch?v=sJIFUTITfBc&t=701s
### Adaptív dinamikus programozás alapú ágensek
Ezeknek az ágenseknek ismerniük kell a teljes modellt:
- az állapotátmenetfüggvényeket
- jutalmazási függvényeket
=> vagyis az MDP-t

Működésének lényege, hogy menet közben megtanulja a környezet állapot-átmenet modelljét, és dinamikus programozási módszerekkel megoldja a hozzá kapcsolható Markov döntési folyamatot.

Passzív tanulási ágens esetén ez azt jelenti, hogy a megtanult állapot-átmenet modellt és a megfigyelt jutalmakat behelyettesíti a Bellmann-egyenletbe ??
	
### Időbeli különbség (TD-temporal difference) alapon hasznosságot tanuló ágens
Az időbeli különbség alapon hasznosságot tanuló ágens lényege, hogy a becslésünket MINDEN LÉPÉSNÉL módosítjuk.

![[Pasted image 20250517185237.png]]

![[Pasted image 20250517185546.png]]

### Aktív megerősítéses tanuló ágens
A passzív ágensnek rögzített stratégiája van (angolul policy jele: π), ezzel szemben az aktív ágensnek el kell döntenie melyik cselekvést válassza, nincs egy előre megadott "szabályrendszer".

Nem csak egy rögzített stratégia modelljét kell megtanulnia, hanem egy teljes modellt, amibe az összes cselekvéseinek lehetséges eredményeihez tartozó valószínűségeik is beletartoznak.

Az aktív megősítéses tanuló ágensnek nincsen előre meghatározott stratégiája, neki kell megtanulnia milyen állapothoz milyen cselekvést válasszon.


### Felfedezés és kihasználás (exploration és exploitation) módszere
Az aktív megerősítéses tanuló ágensek használják az exploration és az exploitation-t

A KIHASZNÁLÁS a jelenlegi hasznosságbecslésben tükrözött modell alapján történő maximalizálás, a FELFEDEZÉS pedig új állapotok, cselekvések megtétele kísérletezés, vizsgálja az új állapotok vagy cselekvések hasznosságát a környezetben.


![[Pasted image 20250517181209.png]]
![[Pasted image 20250517181253.png]]
![[Pasted image 20250517181324.png]]

Kihasználás: 

A felfedezés és kihasználás lényege, hogy az aktív megerősítéses tanuló ágens képes beragadni bizonyos stratégiákba, amelyek nem optimálisak, így felfedezést használhatjuk fel arra, hogy ezen stratégián kívül eső lépést hajtsunk végre és ebből a lépésből az ágensünk tanulni tudjon.

### Q-tanuló ágens





Az Időbeli különbség alapú ágens egy speciális esete, amely nemcsak az állapotokat értékeli, hanem megtanulja, hogy egy bizonyos cselekvés egy bizonyos állapotból mennyire hasznos

Q-értékeket használ, amelyek alapján kitudja választani mi a legjobb döntés.

megjegyzés: azért "Q" tanuló ágens, mert azt tanulja meg, hogy egy adott cselekvésnek milyen minőségű ("QUALITY").



